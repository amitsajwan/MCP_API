#!/usr/bin/env python3
"""
FastAPI-based Chatbot Application (frontend)
- Serves a simple HTML chat UI at /
- Uses ChatbotFastMCPClient (HTTP client) to communicate with the OpenAPI MCP Server
"""

import json
import logging
import os
from datetime import datetime
from typing import Dict, Any, Optional, Set
from fastapi import FastAPI, Request, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse
from pydantic import BaseModel, Field
import uvicorn
import asyncio
from dotenv import load_dotenv
from pathlib import Path
from typing import List

# Ensure .env variables are loaded for this process
load_dotenv()

from mcp_llm_client import MCPLLMClient

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("chatbot_app")

app = FastAPI(title="Financial API Chatbot", version="1.0")

# Structured access logging middleware
@app.middleware("http")
async def access_log(request: Request, call_next):
    logger.info("HTTP %s %s", request.method, request.url.path)
    try:
        response = await call_next(request)
    except Exception as e:
        logger.exception("Request failed: %s %s -> %s", request.method, request.url.path, e)
        raise
    logger.info("HTTP %s %s -> %s", request.method, request.url.path, getattr(response, 'status_code', '?'))
    return response

# Serve production frontend build if available (generated by `npm run build` in frontend/)
if os.path.isdir("frontend/dist"):
    app.mount("/app", StaticFiles(directory="frontend/dist", html=True), name="frontend")

# CORS for React dev server (default Vite 9517 / CRA 3000)
app.add_middleware(
    CORSMiddleware,
    allow_origins=[],  # use regex instead for all localhost ports
    allow_origin_regex=r"http://(localhost|127\.0\.0\.1):\d+",
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# global client
mcp_client: Optional[MCPLLMClient] = None

# simple in-memory session store
sessions: Dict[str, Dict[str, Any]] = {}


def get_or_create_session(session_id: str):
    if session_id not in sessions:
        sessions[session_id] = {"conversation_history": [], "created_at": datetime.now().isoformat(), "last_activity": datetime.now().isoformat()}
    else:
        sessions[session_id]["last_activity"] = datetime.now().isoformat()
    return sessions[session_id]


# Pydantic models

class AssistantRequest(BaseModel):
    message: str
    session_id: Optional[str] = None
    auto_execute: bool = True
    max_tools: int = 1

class AssistantResponse(BaseModel):
    mode: str = "assistant"
    message: str
    session_id: str
    plan: List[Dict[str, Any]]
    executions: Optional[List[Dict[str, Any]]] = None
    answer: Optional[str] = None
    response: Optional[Any] = None

class CredentialsRequest(BaseModel):
    username: str
    password: str
    api_key_name: Optional[str] = None
    api_key_value: Optional[str] = None
    login_url: Optional[str] = None




@app.on_event("startup")
async def startup_event():
    global mcp_client
    logger.info("Starting app and creating MCP LLM client...")
    mcp_server_endpoint = os.getenv('MCP_SERVER_ENDPOINT', 'http://localhost:9000')
    mcp_client = MCPLLMClient(mcp_server_endpoint)
    try:
        # Test connection by listing tools
        tools = await mcp_client.list_tools()
        if tools:
            logger.info(f"Connected to MCP server. Found {len(tools)} tools.")
        else:
            logger.warning(f"MCP server not reachable at startup ({mcp_server_endpoint}).")
    except Exception as e:
        logger.exception("Startup health check failed: %s", e)


@app.on_event("shutdown")
async def shutdown_event():
    global mcp_client
    if mcp_client:
        await mcp_client.close()
        logger.info("MCP client closed.")
 
 
from typing import List

class ToolSchema(BaseModel):
    name: str
    description: str

@app.get("/tools", response_model=List[ToolSchema])
async def get_tools():
    """
    Returns a flat list of tools/endpoints exposed by the MCP server.
    """
    result = await mcp_client.list_tools()

    if result.get("status") != "success":
        # something went wrong upstream
        detail = result.get("message", "Unknown error fetching tools")
        raise HTTPException(status_code=502, detail=detail)

    # unwrap and return only the list of tools
    return result["tools"]

@app.get("/")
async def root():
    return {"message": "MCP-based API Assistant", "endpoints": ["/credentials", "/login", "/assistant/chat", "/status", "/tools", "/simple"]}

@app.get("/simple", response_class=HTMLResponse)
async def simple_ui():
        """Return the minimal UI from the external HTML file to avoid inline JS duplication and escaping issues."""
        try:
            html_path = Path(__file__).resolve().parent / "simple_ui.html"
            content = html_path.read_text(encoding="utf-8")
            return HTMLResponse(content=content)
        except Exception as e:
            logger.exception("Failed to read simple_ui.html: %s", e)
            fallback = """
            <!DOCTYPE html>
            <html><head><meta charset='UTF-8'><title>API Assistant (Simple)</title></head>
            <body><p>Failed to load simple_ui.html. Check server logs.</p></body></html>
            """
            return HTMLResponse(content=fallback, status_code=500)
        html = """
        <!DOCTYPE html>
        <html lang='en'>
        <head>
            <meta charset='UTF-8'/>
            <title>API Assistant (Simple)</title>
            <style>
                :root { color-scheme: dark; }
                body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Arial,sans-serif; background:#111; color:#eee; display:flex; flex-direction:column; height:100vh; }
                header { padding:0.75rem 1rem; background:#181818; font-weight:600; letter-spacing:.5px; }
                #log { flex:1; overflow:auto; padding:1rem; line-height:1.4; }
                .msg { margin:0 0 .85rem; }
                .msg.user { color:#9ad6ff; }
                .msg.assistant { color:#c6f6c6; }
                .msg.system { color:#aaa; font-style:italic; }
                .bubble { padding:.6rem .75rem; background:#222; border-radius:8px; display:inline-block; max-width:70ch; white-space:pre-wrap; word-break:break-word; }
                .user .bubble { background:#123d55; }
                .assistant .bubble { background:#1d3d1d; }
                form { display:flex; gap:.5rem; padding:.75rem; background:#181818; }
                input[type=text] { flex:1; padding:.55rem .7rem; border:1px solid #333; border-radius:6px; background:#101010; color:#eee; }
                input[type=text]:focus { outline:2px solid #2c5aa0; }
                button { padding:.55rem 1rem; border:1px solid #2d5fff; background:#2d5fff; color:#fff; border-radius:6px; cursor:pointer; font-weight:600; }
                button:disabled { opacity:.55; cursor:progress; }
                .toolbar { display:flex; gap:1rem; align-items:center; padding:0 .75rem .5rem; font-size:.8rem; flex-wrap:wrap; }
                label { display:inline-flex; align-items:center; gap:.35rem; cursor:pointer; }
                .small { font-size:.7rem; opacity:.65; }
                #status { font-size:.7rem; opacity:.7; margin-left:auto; }
                a { color:#58a6ff; }
            </style>
        </head>
        <body>
            <header>API Assistant (Simple)</header>
            <div class='toolbar'>
                <span class='small'>Type a prompt like: <code>pending payments status=pending</code> or <code>cash summary</code></span>
                <span id='status'>Idle</span>
                <button id='cfgBtn' style='margin-left:auto'>Configure</button>
            </div>

            <div id='log'></div>
            <dialog id='cfgDlg'>
                <form method='dialog' id='cfgForm' style='display:flex;flex-direction:column;gap:.5rem;min-width:320px;'>
                    <h3>Configure Credentials</h3>
                    <label>Username <input type='text' id='cfgUser' required></label>
                    <label>Password <input type='password' id='cfgPass' required></label>
                    <label>Base URL <input type='text' id='cfgBase' placeholder='http://127.0.0.1:9001' required></label>
                    <div style='display:flex;gap:.5rem;justify-content:flex-end'>
                        <button value='cancel'>Cancel</button>
                        <button id='cfgSave' value='default'>Save</button>
                    </div>
                    <p class='small'>Tip: DEV/TE1/TE2 can be mapped by Base URL (e.g., http://dev-host:port)</p>
                </form>
            </dialog>
            <form id='chatForm'>
                <input id='input' type='text' autocomplete='off' placeholder='Ask something (e.g., show pending payments status=pending)' />
                <button id='sendBtn' type='submit'>Send</button>

            </form>
            <script>
                const logEl = document.getElementById('log');
                const form = document.getElementById('chatForm');
                const input = document.getElementById('input');
                const statusEl = document.getElementById('status');
                const sendBtn = document.getElementById('sendBtn');
                const cfgBtn = document.getElementById('cfgBtn');
                const cfgDlg = document.getElementById('cfgDlg');
                const cfgForm = document.getElementById('cfgForm');
                const cfgUser = document.getElementById('cfgUser');
                const cfgPass = document.getElementById('cfgPass');
                const cfgBase = document.getElementById('cfgBase');
                
                // Surface JS errors in the UI so users see why nothing appears
                function logErrorToUI(text){
                    try{
                        const wrap = document.createElement('div');
                        wrap.className = 'msg system';
                        const bubble = document.createElement('div');
                        bubble.className = 'bubble';
                        bubble.textContent = String(text);
                        wrap.appendChild(bubble);
                        logEl.appendChild(wrap);
                        logEl.scrollTop = logEl.scrollHeight;
                    }catch(_e){ /* ignore */ }
                }
                window.addEventListener('error', (e)=>{
                    const msg = e && (e.message || (e.error && e.error.message)) || 'Unknown script error';
                    logErrorToUI('JS Error: ' + msg);
                });
                window.addEventListener('unhandledrejection', (e)=>{
                    const r = e && e.reason;
                    const msg = typeof r === 'string' ? r : (r && r.message) ? r.message : (r ? JSON.stringify(r) : 'Unknown promise rejection');
                    logErrorToUI('Unhandled rejection: ' + msg);
                });
                
                let currentPlan = null;
                function add(role, content){
                    const wrap = document.createElement('div');
                    wrap.className = 'msg ' + role;
                    const bubble = document.createElement('div');
                    bubble.className = 'bubble';

                    let displayText = content;
                    let plan = null;
                    let executions = null;

                    if(role === 'assistant' && content && typeof content === 'object'){
                        plan = (typeof content.plan !== 'undefined') ? content.plan : null;
                        executions = (typeof content.executions !== 'undefined') ? content.executions : null;
                        if(typeof content.answer === 'string'){
                            displayText = content.answer;
                        } else if(typeof content.response === 'string'){
                            displayText = content.response;
                        } else if(content.response && typeof content.response === 'object'){
                            displayText = JSON.stringify(content.response, null, 2);
                        } else if(content.plan){
                            displayText = 'Plan generated.';
                        } else {
                            displayText = JSON.stringify(content, null, 2);
                        }
                    } else if(typeof displayText === 'object'){
                        displayText = JSON.stringify(displayText, null, 2);
                    }

                    bubble.textContent = displayText;
                    wrap.appendChild(bubble);

                    if(role === 'assistant' && (plan || executions)){
                        const details = document.createElement('details');
                        details.style.marginTop = '0.25rem';
                        const summary = document.createElement('summary');
                        summary.textContent = 'Show reasoning / execution details';
                        details.appendChild(summary);

                        if(plan !== null){
                            const prePlan = document.createElement('pre');
                            prePlan.style.whiteSpace = 'pre-wrap';
                            prePlan.style.margin = '0.5rem 0';
                            prePlan.textContent = 'Plan:\\n' + JSON.stringify(plan, null, 2);
                            details.appendChild(prePlan);
                        }
                        if(executions !== null){
                            const preExec = document.createElement('pre');
                            preExec.style.whiteSpace = 'pre-wrap';
                            preExec.style.margin = '0.5rem 0';
                            preExec.textContent = 'Executions:\\n' + JSON.stringify(executions, null, 2);
                            details.appendChild(preExec);
                        }
                        wrap.appendChild(details);
                    }

                    logEl.appendChild(wrap);
                    logEl.scrollTop = logEl.scrollHeight;
                }

                add('system', 'Assistant ready.');

                cfgBtn.addEventListener('click', ()=> cfgDlg.showModal());
                cfgForm.addEventListener('submit', async (e)=>{
                    e.preventDefault();
                    const body = {
                        username: cfgUser.value.trim(),
                        password: cfgPass.value,
                        base_url: cfgBase.value.trim(),
                        environment: 'DEV'
                    };
                    try{
                        const resp = await fetch('/configure', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
                        if(!resp.ok) throw new Error('HTTP '+resp.status);
                        // optionally, update server spec base URLs so tools hit the same env
                        await fetch('http://127.0.0.1:9000/mcp/spec_base_url', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({base_url: body.base_url})}).catch(()=>{});
                        add('system', 'Configuration saved.');
                        cfgDlg.close();
                    }catch(err){
                        add('assistant', 'Config error: '+err.message);
                    }
                });

                async function callAssistant(message){
                    const body = {
                        message,
                        auto_execute: true,
                        max_tools: 3
                    };
                    const resp = await fetch('/assistant/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
                    if(!resp.ok) throw new Error('HTTP '+resp.status);
                        return resp.json();
                }

                form.addEventListener('submit', async (e)=>{
                    e.preventDefault();
                    const text = input.value.trim();
                    if(!text) return;
                    input.value='';
                    add('user', text);
                    statusEl.textContent = 'Thinking…';
                    sendBtn.disabled = true;
                    try {
                        let result = await callAssistant(text);
                        add('assistant', result);
                    } catch(err){
                        add('assistant', 'Error: '+ err.message);
                    } finally {
                        sendBtn.disabled = false;
                        statusEl.textContent = 'Idle';
                        input.focus();
                    }
                });
            </script>
        </body>
        </html>
        """
        return HTMLResponse(content=html)



@app.get("/tool_meta/{tool_name}")
async def get_tool_meta(tool_name: str):
    """Proxy tool metadata (parameters etc.) from MCP server."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    # Call underlying MCP HTTP server directly via aiohttp session
    try:
        # reuse session
        await mcp_client._ensure_session()  # type: ignore
        async with mcp_client._session.get(f"{mcp_client.server_url}/tool_meta/{tool_name}") as resp:  # type: ignore
            if resp.status == 200:
                return await resp.json()
            detail = await resp.text()
            raise HTTPException(status_code=resp.status, detail=detail)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))











@app.post('/credentials', response_model=Dict[str, Any])
async def set_credentials(req: CredentialsRequest):
    """Set credentials for authentication."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail='MCP client not initialized')
    
    try:
        result = await mcp_client.set_credentials(
            username=req.username,
            password=req.password,
            api_key_name=req.api_key_name,
            api_key_value=req.api_key_value,
            login_url=req.login_url
        )
        return result
    except Exception as e:
        logger.error(f"Set credentials error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/login', response_model=Dict[str, Any])
async def login():
    """Login using Basic Auth and return session status."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail='MCP client not initialized')
    
    try:
        result = await mcp_client.login()
        return result
    except Exception as e:
        logger.error(f"Login error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post('/assistant/chat', response_model=AssistantResponse)
async def assistant_chat(req: AssistantRequest):
    """Execute user query using MCP LLM client with automatic planning and tool execution."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail='MCP client not initialized')

    session_id = req.session_id or 'default'
    session = get_or_create_session(session_id)
    session['conversation_history'].append({'role': 'user', 'content': req.message, 'timestamp': datetime.now().isoformat()})

    try:
        # Execute query using MCP LLM client
        result = await mcp_client.execute_query(req.message)
        
        if result.get('status') == 'auth_required':
            # Handle authentication requirement
            return AssistantResponse(
                mode="auth_required",
                message=req.message,
                session_id=session_id,
                answer=f"Authentication required: {result.get('message')}",
                response=result
            )
        
        if result.get('status') == 'error':
            raise HTTPException(status_code=500, detail=result.get('message', 'Query execution failed'))
        
        # Record assistant answer to session
        answer = result.get('answer', 'No answer provided.')
        session['conversation_history'].append({'role': 'assistant', 'content': answer, 'timestamp': datetime.now().isoformat()})
        
        return AssistantResponse(
            mode="assistant",
            message=req.message,
            session_id=session_id,
            plan=result.get('tool_calls', []),
            executions=result.get('results', []),
            answer=answer,
            response=result
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Assistant chat error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/test_endpoint")
async def test_endpoint(data: dict):
    return {"received": data, "status": "ok"}

@app.get("/status")
async def get_status():
    global mcp_client
    if not mcp_client:
        return {"mcp_server_connected": False, "available_tools": 0, "error": "Client not initialized"}
    try:
        connected = await mcp_client.health_check()
        tools_count = 0
        if connected:
            # use list_tools helper
            tools = await mcp_client.list_tools()
            if isinstance(tools, dict) and tools.get("status") == "success":
                tools_count = len(tools.get("tools", []))
            elif isinstance(tools, dict) and "tools" in tools:
                tools_count = len(tools["tools"])
        return {"mcp_server_connected": connected, "available_tools": tools_count, "server_timestamp": datetime.now().isoformat()}
    except Exception as e:
        logger.exception("status check failed")
        return {"mcp_server_connected": False, "available_tools": 0, "error": str(e)}

@app.get("/apis")
async def list_apis():
    """Return loaded spec names and number of tools each (no auth required)."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    specs = await mcp_client.get_tool_meta("list_loaded_specs") if hasattr(mcp_client, 'get_tool_meta') else None  # placeholder
    # Fallback: we can't call list directly via tool_meta; use chat CALL_TOOL fallback
    result = await mcp_client.call_tool("list_loaded_specs")
    if result.get("status") == "success" and "specs" in result:
        return result
    return {"status": "error", "message": "Could not retrieve specs", "raw": result}


@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    await websocket.accept()
    global mcp_client
    if not mcp_client:
        await websocket.close(code=1011, reason="Server not initialized")
        return
    try:
        while True:
            data = await websocket.receive_text()
            try:
                payload = json.loads(data)
                message = payload.get("message")
            except Exception:
                message = data
            # forward to backend
            result = await mcp_client.ask_question(message)
            await websocket.send_json({"response": result, "timestamp": datetime.now().isoformat()})
    except WebSocketDisconnect:
        logger.info("WebSocket disconnected for session %s", session_id)
    except Exception as e:
        logger.exception("ws error")
        try:
            await websocket.close(code=1011, reason=str(e))
        except Exception:
            pass


if __name__ == "__main__":
    host = os.getenv('CHATBOT_HOST', '0.0.0.0')
    port = int(os.getenv('CHATBOT_PORT', '9080'))
    logger.info(f"Starting uvicorn for chatbot_app on {host}:{port}")
    uvicorn.run("chatbot_app:app", host=host, port=port, reload=True, log_level="info")
