#!/usr/bin/env python3
"""
FastAPI-based Chatbot Application (frontend)
- Serves a simple HTML chat UI at /
- Uses ChatbotFastMCPClient (HTTP client) to communicate with the OpenAPI MCP Server
"""

import json
import logging
import os
from datetime import datetime
from typing import Dict, Any, Optional, Set
from fastapi import FastAPI, Request, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse
from pydantic import BaseModel, Field
import uvicorn
import asyncio
from dotenv import load_dotenv

# Ensure .env variables (e.g., GROQ_API_KEY) are loaded for this process
load_dotenv()
if os.environ.get('GROQ_API_KEY'):
    logging.getLogger('chatbot_app').info('GROQ_API_KEY detected (LLM summaries enabled).')
else:
    logging.getLogger('chatbot_app').info('GROQ_API_KEY not set for chatbot_app (will use fallback summaries).')

from fastmcp_client import ChatbotFastMCPClient
from assistant_core import synthesize_answer

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("chatbot_app")

app = FastAPI(title="Financial API Chatbot", version="1.0")

# Structured access logging middleware
@app.middleware("http")
async def access_log(request: Request, call_next):
    logger.info("HTTP %s %s", request.method, request.url.path)
    try:
        response = await call_next(request)
    except Exception as e:
        logger.exception("Request failed: %s %s -> %s", request.method, request.url.path, e)
        raise
    logger.info("HTTP %s %s -> %s", request.method, request.url.path, getattr(response, 'status_code', '?'))
    return response

# Serve production frontend build if available (generated by `npm run build` in frontend/)
if os.path.isdir("frontend/dist"):
    app.mount("/app", StaticFiles(directory="frontend/dist", html=True), name="frontend")

# CORS for React dev server (default Vite 5173 / CRA 3000)
app.add_middleware(
    CORSMiddleware,
    allow_origins=[],  # use regex instead for all localhost ports
    allow_origin_regex=r"http://(localhost|127\.0\.0\.1):\d+",
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# global client
mcp_client: Optional[ChatbotFastMCPClient] = None

# simple in-memory session store
sessions: Dict[str, Dict[str, Any]] = {}
configurations: Dict[str, Dict[str, Any]] = {}


def get_or_create_session(session_id: str):
    if session_id not in sessions:
        sessions[session_id] = {"conversation_history": [], "created_at": datetime.now().isoformat(), "last_activity": datetime.now().isoformat()}
    else:
        sessions[session_id]["last_activity"] = datetime.now().isoformat()
    return sessions[session_id]


# Pydantic models
class ChatRequest(BaseModel):
    message: str = Field(..., description="User's message")
    session_id: Optional[str] = Field(None, description="session id")


class ChatResponse(BaseModel):
    response: Any
    session_id: str
    timestamp: str

class AssistantRequest(BaseModel):
    message: str
    session_id: Optional[str] = None
    auto_execute: bool = True
    max_tools: int = 1

class AssistantResponse(BaseModel):
    mode: str = "assistant"
    message: str
    session_id: str
    plan: Dict[str, Any]
    executions: Optional[Any] = None
    answer: Optional[str] = None
    # For simple UI compatibility (expects `response` like ChatResponse)
    response: Optional[Any] = None


class ConfigurationRequest(BaseModel):
    username: str
    password: str
    base_url: str
    environment: Optional[str] = "DEV"
    session_id: Optional[str] = None

@app.on_event("startup")
async def startup_event():
    global mcp_client
    logger.info("Starting app and creating MCP HTTP client...")
    mcp_client = ChatbotFastMCPClient(server_url="http://localhost:8000/mcp")
    try:
        ok = await mcp_client.health_check()
        if ok:
            logger.info("Connected to MCP server (HTTP).")
        else:
            logger.warning("MCP server not reachable at startup (http://localhost:8000).")
    except Exception as e:
        logger.exception("Startup health check failed: %s", e)


@app.on_event("shutdown")
async def shutdown_event():
    global mcp_client
    if mcp_client:
        await mcp_client.close()
        logger.info("MCP client closed.")
 
 
from pydantic import BaseModel
from typing import List

class ToolSchema(BaseModel):
    name: str
    description: str

@app.get("/tools", response_model=List[ToolSchema])
async def get_tools():
    """
    Returns a flat list of tools/endpoints exposed by the MCP server.
    """
    result = await mcp_client.list_tools()

    if result.get("status") != "success":
        # something went wrong upstream
        detail = result.get("message", "Unknown error fetching tools")
        raise HTTPException(status_code=502, detail=detail)

    # unwrap and return only the list of tools
    return result["tools"]

@app.get("/")
async def root():
    return {"message": "React UI available separately. See frontend/ directory.", "endpoints": ["/configure", "/chat", "/status", "/tools", "/quick_actions", "/run_tool"]}

@app.get("/simple", response_class=HTMLResponse)
async def simple_ui():
        """Return a minimal, dependency-free conversational UI (assistant-aware)."""
        html = """
        <!DOCTYPE html>
        <html lang='en'>
        <head>
            <meta charset='UTF-8'/>
            <title>API Assistant (Simple)</title>
            <style>
                :root { color-scheme: dark; }
                body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Arial,sans-serif; background:#111; color:#eee; display:flex; flex-direction:column; height:100vh; }
                header { padding:0.75rem 1rem; background:#181818; font-weight:600; letter-spacing:.5px; }
                #log { flex:1; overflow:auto; padding:1rem; line-height:1.4; }
                .msg { margin:0 0 .85rem; }
                .msg.user { color:#9ad6ff; }
                .msg.assistant { color:#c6f6c6; }
                .msg.system { color:#aaa; font-style:italic; }
                .bubble { padding:.6rem .75rem; background:#222; border-radius:8px; display:inline-block; max-width:70ch; white-space:pre-wrap; word-break:break-word; }
                .user .bubble { background:#123d55; }
                .assistant .bubble { background:#1d3d1d; }
                form { display:flex; gap:.5rem; padding:.75rem; background:#181818; }
                input[type=text] { flex:1; padding:.55rem .7rem; border:1px solid #333; border-radius:6px; background:#101010; color:#eee; }
                input[type=text]:focus { outline:2px solid #2c5aa0; }
                button { padding:.55rem 1rem; border:1px solid #2d5fff; background:#2d5fff; color:#fff; border-radius:6px; cursor:pointer; font-weight:600; }
                button:disabled { opacity:.55; cursor:progress; }
                .toolbar { display:flex; gap:1rem; align-items:center; padding:0 .75rem .5rem; font-size:.8rem; flex-wrap:wrap; }
                label { display:inline-flex; align-items:center; gap:.35rem; cursor:pointer; }
                .small { font-size:.7rem; opacity:.65; }
                #status { font-size:.7rem; opacity:.7; margin-left:auto; }
                a { color:#58a6ff; }
            </style>
        </head>
        <body>
            <header>API Assistant (Simple)</header>
            <div class='toolbar'>
                <label><input type='checkbox' id='assistant' checked/> Assistant Auto Tools</label>
                <label>Max Tools <input type='number' id='maxTools' min='1' max='5' value='1' style='width:60px;'/></label>
                <span class='small'>Type a prompt like: <code>pending payments status=pending</code> or <code>cash summary</code></span>
                <span id='status'>Idle</span>
            </div>
            <div id='log'></div>
            <form id='chatForm'>
                <input id='input' type='text' autocomplete='off' placeholder='Ask something (e.g., show pending payments status=pending)' />
                <button id='sendBtn' type='submit'>Send</button>
            </form>
            <script>
                const logEl = document.getElementById('log');
                const form = document.getElementById('chatForm');
                const input = document.getElementById('input');
                const assistantToggle = document.getElementById('assistant');
                const maxTools = document.getElementById('maxTools');
                const statusEl = document.getElementById('status');
                const sendBtn = document.getElementById('sendBtn');

                function add(role, content){
                    const wrap = document.createElement('div');
                    wrap.className = 'msg ' + role;
                    const bubble = document.createElement('div');
                    bubble.className = 'bubble';
                    if(typeof content === 'object') content = JSON.stringify(content, null, 2);
                    bubble.textContent = content;
                    wrap.appendChild(bubble);
                    logEl.appendChild(wrap);
                    logEl.scrollTop = logEl.scrollHeight;
                }

                add('system', 'Assistant ready.');

                async function callAssistant(message){
                    const body = {
                        message,
                        auto_execute: true,
                        max_tools: parseInt(maxTools.value)||1
                    };
                    const resp = await fetch('/assistant/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
                    if(!resp.ok) throw new Error('HTTP '+resp.status);
                        return resp.json();
                }
                async function callChat(message){
                    const body = {message};
                    const resp = await fetch('/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
                    if(!resp.ok) throw new Error('HTTP '+resp.status);
                    return resp.json();
                }

                form.addEventListener('submit', async (e)=>{
                    e.preventDefault();
                    const text = input.value.trim();
                    if(!text) return;
                    input.value='';
                    add('user', text);
                    statusEl.textContent = 'Thinkingâ€¦';
                    sendBtn.disabled = true;
                    try {
                        let result;
                        if(assistantToggle.checked){
                            result = await callAssistant(text);
                        } else {
                            result = await callChat(text); // returns ChatResponse shape
                        }
                        add('assistant', result.response || result.plan || result);
                    } catch(err){
                        add('assistant', 'Error: '+ err.message);
                    } finally {
                        sendBtn.disabled = false;
                        statusEl.textContent = 'Idle';
                        input.focus();
                    }
                });
            </script>
        </body>
        </html>
        """
        return HTMLResponse(content=html)

@app.get("/quick_actions")
async def quick_actions():
    """Return a curated list of tools to display as quick actions (currently all tools)."""
    result = await get_tools()  # reuse existing logic
    # Could add filtering / sorting later
    return result

@app.get("/tool_meta/{tool_name}")
async def get_tool_meta(tool_name: str):
    """Proxy tool metadata (parameters etc.) from MCP server."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    # Call underlying MCP HTTP server directly via aiohttp session
    try:
        # reuse session
        await mcp_client._ensure_session()  # type: ignore
        async with mcp_client._session.get(f"{mcp_client.server_url}/tool_meta/{tool_name}") as resp:  # type: ignore
            if resp.status == 200:
                return await resp.json()
            detail = await resp.text()
            raise HTTPException(status_code=resp.status, detail=detail)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/run_tool")
async def run_tool(payload: Dict[str, Any]):
    """Directly execute a tool (wrapper around MCP client)."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    tool_name = payload.get("tool_name")
    arguments = payload.get("arguments") or {}
    if not tool_name:
        raise HTTPException(status_code=400, detail="tool_name required")
    try:
        result = await mcp_client.call_tool(tool_name, **arguments)
        logger.info("/run_tool %s -> status=%s code=%s", tool_name, result.get('status'), result.get('status_code'))
        return {"status": "success", "tool": tool_name, "result": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/configure")
async def configure_credentials(req: ConfigurationRequest):
    global mcp_client, configurations
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    session_id = req.session_id or "default"
    configurations[session_id] = {
        "username": req.username,
        "password": req.password,
        "base_url": req.base_url,
        "environment": req.environment,
        "configured_at": datetime.now().isoformat()
    }
    # apply to global client (for simplicity)
    mcp_client.username = req.username
    mcp_client.password = req.password
    mcp_client.base_url = req.base_url
    mcp_client.environment = req.environment
    # mark unauthenticated so next ask_question triggers login attempt
    mcp_client.authenticated = False
    return {"status": "success", "message": "configuration stored"}


@app.get("/configuration/{session_id}")
async def get_configuration(session_id: str):
    cfg = configurations.get(session_id)
    if not cfg:
        return JSONResponse(status_code=404, content={"status": "not_configured", "message": "No configuration for this session."})
    return {"status": "configured", "username": cfg["username"], "base_url": cfg["base_url"], "environment": cfg["environment"], "configured_at": cfg["configured_at"]}


@app.post("/chat", response_model=ChatResponse)
async def chat_endpoint(req: ChatRequest):
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")

    session_id = req.session_id or "default"
    session = get_or_create_session(session_id)
    session["conversation_history"].append({"role": "user", "content": req.message, "timestamp": datetime.now().isoformat()})

    cfg = configurations.get(session_id)
    if not cfg:
        # Allow discovery questions pre-configuration
        lowered = req.message.lower().strip()
        # Broad heuristic: question contains 'api' or 'endpoint' and a query word
        query_words = ["what", "which", "list", "show", "available"]
        if ("api" in lowered or "endpoint" in lowered) and any(q in lowered for q in query_words):
            specs_result = await mcp_client.call_tool("list_loaded_specs")
            endpoints_result = await mcp_client.call_tool("list_api_endpoints")
            specs = specs_result.get("specs", []) if isinstance(specs_result, dict) else []
            grouped = endpoints_result.get("grouped", {}) if isinstance(endpoints_result, dict) else {}
            endpoint_count = endpoints_result.get("count", sum(len(v) for v in grouped.values())) if isinstance(endpoints_result, dict) else 0
            human_list = ", ".join([s.get("name", "?") for s in specs]) or "(none loaded)"
            summary = {
                "status": "success",
                "message": f"Loaded API specs: {human_list} ({endpoint_count} endpoints). Use /configure or the UI configuration to add credentials.",
                "specs": specs,
                "endpoint_count": endpoint_count,
                "grouped": grouped
            }
            return ChatResponse(response=summary, session_id=session_id, timestamp=datetime.now().isoformat())
        return ChatResponse(response={"status": "configuration_required", "message": "Please configure your credentials."}, session_id=session_id, timestamp=datetime.now().isoformat())

    # apply config to client for this request
    mcp_client.username = cfg["username"]
    mcp_client.password = cfg["password"]
    mcp_client.base_url = cfg["base_url"]
    mcp_client.environment = cfg.get("environment", "DEV")

    # ensure login
    if not mcp_client.authenticated:
        login_result = await mcp_client.login()
        if login_result.get("status") == "error":
            return ChatResponse(response={"status": "error", "message": f"Login failed: {login_result.get('message')}"} , session_id=session_id, timestamp=datetime.now().isoformat())
        mcp_client.authenticated = True

    # ask question
    answer = await mcp_client.ask_question(req.message)
    # store assistant reply to session history (best-effort)
    session["conversation_history"].append({"role": "assistant", "content": answer, "timestamp": datetime.now().isoformat()})

    logger.info("/chat answer ready, type=%s", type(answer).__name__)

    return ChatResponse(response=answer, session_id=session_id, timestamp=datetime.now().isoformat())


# Removed legacy helper aliases for minimal demo

def _synthesize_answer(executions: list) -> str:
    if not executions:
        return "No tool executions were performed."
    lines = []
    aggregate_counts = []
    for ex in executions:
        if ex.get('status') != 'success':
            lines.append(f"{ex.get('tool')}: error {ex.get('error')}")
            continue
        res = ex.get('result')
        # Standard FastAPI endpoint wrapper shape {status, url, status_code, response}
        payload = res.get('response') if isinstance(res, dict) else res
        count_info = None
        # Try to locate primary list
        if isinstance(payload, list):
            count_info = (len(payload), 'items')
        elif isinstance(payload, dict):
            # pick the largest list value
            best_key = None; best_len = -1
            for k,v in payload.items():
                if isinstance(v, list):
                    l = len(v)
                    if l > best_len:
                        best_len = l; best_key = k
            if best_key is not None:
                count_info = (best_len, best_key)
        if count_info:
            n, label = count_info
            aggregate_counts.append((ex.get('tool'), n, label))
            lines.append(f"{ex.get('tool')}: {n} {label}")
        else:
            lines.append(f"{ex.get('tool')}: succeeded")
    if not aggregate_counts:
        return "; ".join(lines)
    summary_parts = [f"{n} from {tool}" for tool, n, _ in aggregate_counts]
    total = sum(n for _, n, _ in aggregate_counts)
    return "; ".join(lines) + f". Total items across tools: {total} (" + ", ".join(summary_parts) + ")"

@app.post('/assistant/chat', response_model=AssistantResponse)
async def assistant_chat(req: AssistantRequest):
    """Assistant mode using LLM agent for planning/execution (minimal logic).
    The LLM decides the best tool(s); we then synthesize an answer.
    """
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail='MCP client not initialized')

    session_id = req.session_id or 'default'
    session = get_or_create_session(session_id)
    session['conversation_history'].append({'role': 'user', 'content': req.message, 'timestamp': datetime.now().isoformat()})

    # Call the server's LLM agent endpoint directly (only if available)
    agent = None
    try:
        await mcp_client._ensure_session()  # type: ignore
        base_url = mcp_client.server_url.rsplit('/mcp', 1)[0]
        # Preflight: check if LLM router is mounted
        llm_ready = False
        try:
            async with mcp_client._session.get(f"{base_url}/llm/status") as s:  # type: ignore
                llm_ready = (s.status == 200)
        except Exception:
            llm_ready = False
        if llm_ready:
            payload = {
                'message': req.message,
                'max_steps': max(1, int(req.max_tools or 1)),
                'dry_run': False
            }
            async with mcp_client._session.post(f"{base_url}/llm/agent", json=payload) as resp:  # type: ignore
                if resp.status == 200:
                    agent = await resp.json()
                else:
                    agent = None
    except Exception:
        # Any error -> fallback to client-side planning
        agent = None

    # Agent returns plan and (optionally) executions
    plan_steps = (agent.get('plan') if isinstance(agent, dict) else None) or []
    executions = (agent.get('executions') if isinstance(agent, dict) else None) or []
    # Minimal client-side fallback planning if LLM route is unavailable or returned no steps
    if not plan_steps:
        tools_result = await mcp_client.list_tools()
        tool_names = [t.get('name') for t in tools_result.get('tools', []) if isinstance(t, dict)] if isinstance(tools_result, dict) else []
        text = (req.message or '').lower()
        def pick(*hints: str):
            for h in hints:
                for tn in tool_names:
                    if h in tn.lower():
                        return tn
            return None
        chosen = None
        args = {}
        if 'pending payments' in text:
            chosen = pick('getpayments', 'payments')
            args = {'status': 'pending'}
        elif 'payments' in text:
            chosen = pick('getpayments', 'payments')
        elif 'transactions' in text:
            chosen = pick('gettransactions', 'transactions')
        elif 'cash' in text or 'summary' in text:
            chosen = pick('getcashsummary', 'summary', 'cash')
        if not chosen and tool_names:
            chosen = tool_names[0]
        if chosen:
            plan_steps = [{'tool': chosen, 'arguments': args}]
    # If executions are not provided (dry_run), execute selected plan here
    if req.auto_execute and not executions:
        for step in plan_steps[: max(1, int(req.max_tools or 1))]:
            t = step.get('tool'); args = step.get('arguments') or {}
            try:
                result = await mcp_client.call_tool(t, **args)
                executions.append({'tool': t, 'status': 'success', 'result': result})
            except Exception as e:
                executions.append({'tool': t, 'status': 'error', 'error': str(e)})

    plan = {
        'agent_note': (agent.get('notes') if isinstance(agent, dict) else None),
        'selected': [s.get('tool') for s in plan_steps],
        'arguments': {s.get('tool'): s.get('arguments') for s in plan_steps},
        'executed': bool(executions)
    }

    answer = synthesize_answer(executions) if executions else None
    if answer:
        session['conversation_history'].append({'role': 'assistant', 'content': answer, 'timestamp': datetime.now().isoformat()})
    session['conversation_history'].append({'role': 'assistant', 'content': plan, 'timestamp': datetime.now().isoformat()})
    logger.info("/assistant/chat plan=%s executed=%s", plan.get('selected'), bool(executions))
    return AssistantResponse(message=req.message, session_id=session_id, plan=plan, executions=executions, answer=answer, response=answer)


@app.get("/status")
async def get_status():
    global mcp_client
    if not mcp_client:
        return {"mcp_server_connected": False, "available_tools": 0, "error": "Client not initialized"}
    try:
        connected = await mcp_client.health_check()
        tools_count = 0
        if connected:
            # use list_tools helper
            tools = await mcp_client.list_tools()
            if isinstance(tools, dict) and tools.get("status") == "success":
                tools_count = len(tools.get("tools", []))
            elif isinstance(tools, dict) and "tools" in tools:
                tools_count = len(tools["tools"])
        return {"mcp_server_connected": connected, "available_tools": tools_count, "server_timestamp": datetime.now().isoformat()}
    except Exception as e:
        logger.exception("status check failed")
        return {"mcp_server_connected": False, "available_tools": 0, "error": str(e)}

@app.get("/apis")
async def list_apis():
    """Return loaded spec names and number of tools each (no auth required)."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    specs = await mcp_client.get_tool_meta("list_loaded_specs") if hasattr(mcp_client, 'get_tool_meta') else None  # placeholder
    # Fallback: we can't call list directly via tool_meta; use chat CALL_TOOL fallback
    result = await mcp_client.call_tool("list_loaded_specs")
    if result.get("status") == "success" and "specs" in result:
        return result
    return {"status": "error", "message": "Could not retrieve specs", "raw": result}


@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    await websocket.accept()
    global mcp_client
    if not mcp_client:
        await websocket.close(code=1011, reason="Server not initialized")
        return
    try:
        while True:
            data = await websocket.receive_text()
            try:
                payload = json.loads(data)
                message = payload.get("message")
            except Exception:
                message = data
            # forward to backend
            result = await mcp_client.ask_question(message)
            await websocket.send_json({"response": result, "timestamp": datetime.now().isoformat()})
    except WebSocketDisconnect:
        logger.info("WebSocket disconnected for session %s", session_id)
    except Exception as e:
        logger.exception("ws error")
        try:
            await websocket.close(code=1011, reason=str(e))
        except Exception:
            pass


if __name__ == "__main__":
    logger.info("Starting uvicorn for chatbot_app on 0.0.0.0:8080")
    uvicorn.run("chatbot_app:app", host="0.0.0.0", port=8080, reload=True, log_level="info")
