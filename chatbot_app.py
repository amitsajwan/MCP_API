#!/usr/bin/env python3
"""
FastAPI-based Chatbot Application (frontend)
- Serves a simple HTML chat UI at /
- Uses ChatbotFastMCPClient (HTTP client) to communicate with the OpenAPI MCP Server
"""

import json
import logging
import os
from datetime import datetime
from typing import Dict, Any, Optional
from fastapi import FastAPI, Request, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse
from pydantic import BaseModel, Field
import uvicorn
import asyncio

from fastmcp_client import ChatbotFastMCPClient

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("chatbot_app")

app = FastAPI(title="Financial API Chatbot", version="1.0")

# Serve production frontend build if available (generated by `npm run build` in frontend/)
if os.path.isdir("frontend/dist"):
    app.mount("/app", StaticFiles(directory="frontend/dist", html=True), name="frontend")

# CORS for React dev server (default Vite 5173 / CRA 3000)
app.add_middleware(
    CORSMiddleware,
    allow_origins=[],  # use regex instead for all localhost ports
    allow_origin_regex=r"http://(localhost|127\.0\.0\.1):\d+",
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# global client
mcp_client: Optional[ChatbotFastMCPClient] = None

# simple in-memory session store
sessions: Dict[str, Dict[str, Any]] = {}
configurations: Dict[str, Dict[str, Any]] = {}


def get_or_create_session(session_id: str):
    if session_id not in sessions:
        sessions[session_id] = {"conversation_history": [], "created_at": datetime.now().isoformat(), "last_activity": datetime.now().isoformat()}
    else:
        sessions[session_id]["last_activity"] = datetime.now().isoformat()
    return sessions[session_id]


# Pydantic models
class ChatRequest(BaseModel):
    message: str = Field(..., description="User's message")
    session_id: Optional[str] = Field(None, description="session id")


class ChatResponse(BaseModel):
    response: Any
    session_id: str
    timestamp: str


class ConfigurationRequest(BaseModel):
    username: str
    password: str
    base_url: str
    environment: Optional[str] = "DEV"
    session_id: Optional[str] = None

@app.on_event("startup")
async def startup_event():
    global mcp_client
    logger.info("Starting app and creating MCP HTTP client...")
    mcp_client = ChatbotFastMCPClient(server_url="http://localhost:8000/mcp")
    try:
        ok = await mcp_client.health_check()
        if ok:
            logger.info("Connected to MCP server (HTTP).")
        else:
            logger.warning("MCP server not reachable at startup (http://localhost:8000).")
    except Exception as e:
        logger.exception("Startup health check failed: %s", e)


@app.on_event("shutdown")
async def shutdown_event():
    global mcp_client
    if mcp_client:
        await mcp_client.close()
        logger.info("MCP client closed.")
 
 
from pydantic import BaseModel
from typing import List

class ToolSchema(BaseModel):
    name: str
    description: str

@app.get("/tools", response_model=List[ToolSchema])
async def get_tools():
    """
    Returns a flat list of tools/endpoints exposed by the MCP server.
    """
    result = await mcp_client.list_tools()

    if result.get("status") != "success":
        # something went wrong upstream
        detail = result.get("message", "Unknown error fetching tools")
        raise HTTPException(status_code=502, detail=detail)

    # unwrap and return only the list of tools
    return result["tools"]

@app.get("/")
async def root():
    return {"message": "React UI available separately. See frontend/ directory.", "endpoints": ["/configure", "/chat", "/status", "/tools", "/quick_actions", "/run_tool"]}

@app.get("/quick_actions")
async def quick_actions():
    """Return a curated list of tools to display as quick actions (currently all tools)."""
    result = await get_tools()  # reuse existing logic
    # Could add filtering / sorting later
    return result

@app.get("/tool_meta/{tool_name}")
async def get_tool_meta(tool_name: str):
    """Proxy tool metadata (parameters etc.) from MCP server."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    # Call underlying MCP HTTP server directly via aiohttp session
    try:
        # reuse session
        await mcp_client._ensure_session()  # type: ignore
        async with mcp_client._session.get(f"{mcp_client.server_url}/tool_meta/{tool_name}") as resp:  # type: ignore
            if resp.status == 200:
                return await resp.json()
            detail = await resp.text()
            raise HTTPException(status_code=resp.status, detail=detail)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/run_tool")
async def run_tool(payload: Dict[str, Any]):
    """Directly execute a tool (wrapper around MCP client)."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    tool_name = payload.get("tool_name")
    arguments = payload.get("arguments") or {}
    if not tool_name:
        raise HTTPException(status_code=400, detail="tool_name required")
    try:
        result = await mcp_client.call_tool(tool_name, **arguments)
        return {"status": "success", "tool": tool_name, "result": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/configure")
async def configure_credentials(req: ConfigurationRequest):
    global mcp_client, configurations
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    session_id = req.session_id or "default"
    configurations[session_id] = {
        "username": req.username,
        "password": req.password,
        "base_url": req.base_url,
        "environment": req.environment,
        "configured_at": datetime.now().isoformat()
    }
    # apply to global client (for simplicity)
    mcp_client.username = req.username
    mcp_client.password = req.password
    mcp_client.base_url = req.base_url
    mcp_client.environment = req.environment
    # mark unauthenticated so next ask_question triggers login attempt
    mcp_client.authenticated = False
    return {"status": "success", "message": "configuration stored"}


@app.get("/configuration/{session_id}")
async def get_configuration(session_id: str):
    cfg = configurations.get(session_id)
    if not cfg:
        return JSONResponse(status_code=404, content={"status": "not_configured", "message": "No configuration for this session."})
    return {"status": "configured", "username": cfg["username"], "base_url": cfg["base_url"], "environment": cfg["environment"], "configured_at": cfg["configured_at"]}


@app.post("/chat", response_model=ChatResponse)
async def chat_endpoint(req: ChatRequest):
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")

    session_id = req.session_id or "default"
    session = get_or_create_session(session_id)
    session["conversation_history"].append({"role": "user", "content": req.message, "timestamp": datetime.now().isoformat()})

    cfg = configurations.get(session_id)
    if not cfg:
        # Allow discovery questions pre-configuration
        lowered = req.message.lower().strip()
        # Broad heuristic: question contains 'api' or 'endpoint' and a query word
        query_words = ["what", "which", "list", "show", "available"]
        if ("api" in lowered or "endpoint" in lowered) and any(q in lowered for q in query_words):
            specs_result = await mcp_client.call_tool("list_loaded_specs")
            endpoints_result = await mcp_client.call_tool("list_api_endpoints")
            specs = specs_result.get("specs", []) if isinstance(specs_result, dict) else []
            grouped = endpoints_result.get("grouped", {}) if isinstance(endpoints_result, dict) else {}
            endpoint_count = endpoints_result.get("count", sum(len(v) for v in grouped.values())) if isinstance(endpoints_result, dict) else 0
            human_list = ", ".join([s.get("name", "?") for s in specs]) or "(none loaded)"
            summary = {
                "status": "success",
                "message": f"Loaded API specs: {human_list} ({endpoint_count} endpoints). Use /configure or the UI configuration to add credentials.",
                "specs": specs,
                "endpoint_count": endpoint_count,
                "grouped": grouped
            }
            return ChatResponse(response=summary, session_id=session_id, timestamp=datetime.now().isoformat())
        return ChatResponse(response={"status": "configuration_required", "message": "Please configure your credentials."}, session_id=session_id, timestamp=datetime.now().isoformat())

    # apply config to client for this request
    mcp_client.username = cfg["username"]
    mcp_client.password = cfg["password"]
    mcp_client.base_url = cfg["base_url"]
    mcp_client.environment = cfg.get("environment", "DEV")

    # ensure login
    if not mcp_client.authenticated:
        login_result = await mcp_client.login()
        if login_result.get("status") == "error":
            return ChatResponse(response={"status": "error", "message": f"Login failed: {login_result.get('message')}"} , session_id=session_id, timestamp=datetime.now().isoformat())
        mcp_client.authenticated = True

    # ask question
    answer = await mcp_client.ask_question(req.message)
    # store assistant reply to session history (best-effort)
    session["conversation_history"].append({"role": "assistant", "content": answer, "timestamp": datetime.now().isoformat()})

    return ChatResponse(response=answer, session_id=session_id, timestamp=datetime.now().isoformat())


@app.get("/status")
async def get_status():
    global mcp_client
    if not mcp_client:
        return {"mcp_server_connected": False, "available_tools": 0, "error": "Client not initialized"}
    try:
        connected = await mcp_client.health_check()
        tools_count = 0
        if connected:
            # use list_tools helper
            tools = await mcp_client.list_tools()
            if isinstance(tools, dict) and tools.get("status") == "success":
                tools_count = len(tools.get("tools", []))
            elif isinstance(tools, dict) and "tools" in tools:
                tools_count = len(tools["tools"])
        return {"mcp_server_connected": connected, "available_tools": tools_count, "server_timestamp": datetime.now().isoformat()}
    except Exception as e:
        logger.exception("status check failed")
        return {"mcp_server_connected": False, "available_tools": 0, "error": str(e)}

@app.get("/apis")
async def list_apis():
    """Return loaded spec names and number of tools each (no auth required)."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    specs = await mcp_client.get_tool_meta("list_loaded_specs") if hasattr(mcp_client, 'get_tool_meta') else None  # placeholder
    # Fallback: we can't call list directly via tool_meta; use chat CALL_TOOL fallback
    result = await mcp_client.call_tool("list_loaded_specs")
    if result.get("status") == "success" and "specs" in result:
        return result
    return {"status": "error", "message": "Could not retrieve specs", "raw": result}


@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    await websocket.accept()
    global mcp_client
    if not mcp_client:
        await websocket.close(code=1011, reason="Server not initialized")
        return
    try:
        while True:
            data = await websocket.receive_text()
            try:
                payload = json.loads(data)
                message = payload.get("message")
            except Exception:
                message = data
            # forward to backend
            result = await mcp_client.ask_question(message)
            await websocket.send_json({"response": result, "timestamp": datetime.now().isoformat()})
    except WebSocketDisconnect:
        logger.info("WebSocket disconnected for session %s", session_id)
    except Exception as e:
        logger.exception("ws error")
        try:
            await websocket.close(code=1011, reason=str(e))
        except Exception:
            pass


if __name__ == "__main__":
    logger.info("Starting uvicorn for chatbot_app on 0.0.0.0:8080")
    uvicorn.run("chatbot_app:app", host="0.0.0.0", port=8080, reload=True, log_level="info")
