#!/usr/bin/env python3
"""
FastAPI-based Chatbot Application (frontend)
- Serves a simple HTML chat UI at /
- Uses ChatbotFastMCPClient (HTTP client) to communicate with the OpenAPI MCP Server
"""

import json
import logging
import os
from datetime import datetime
from typing import Dict, Any, Optional, Set
from fastapi import FastAPI, Request, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse
from pydantic import BaseModel, Field
import uvicorn
import asyncio
from dotenv import load_dotenv
from pathlib import Path
from typing import List

# Ensure .env variables (e.g., GROQ_API_KEY) are loaded for this process
load_dotenv()
if os.environ.get('GROQ_API_KEY'):
    logging.getLogger('chatbot_app').info('GROQ_API_KEY detected (LLM summaries enabled).')
else:
    logging.getLogger('chatbot_app').info('GROQ_API_KEY not set for chatbot_app (will use fallback summaries).')

from fastmcp_client import ChatbotFastMCPClient
from assistant_core import synthesize_answer, tokenize, score_tool, select_tools, parse_inline_args

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("chatbot_app")

app = FastAPI(title="Financial API Chatbot", version="1.0")

# Structured access logging middleware
@app.middleware("http")
async def access_log(request: Request, call_next):
    logger.info("HTTP %s %s", request.method, request.url.path)
    try:
        response = await call_next(request)
    except Exception as e:
        logger.exception("Request failed: %s %s -> %s", request.method, request.url.path, e)
        raise
    logger.info("HTTP %s %s -> %s", request.method, request.url.path, getattr(response, 'status_code', '?'))
    return response

# Serve production frontend build if available (generated by `npm run build` in frontend/)
if os.path.isdir("frontend/dist"):
    app.mount("/app", StaticFiles(directory="frontend/dist", html=True), name="frontend")

# CORS for React dev server (default Vite 9517 / CRA 3000)
app.add_middleware(
    CORSMiddleware,
    allow_origins=[],  # use regex instead for all localhost ports
    allow_origin_regex=r"http://(localhost|127\.0\.0\.1):\d+",
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# global client
mcp_client: Optional[ChatbotFastMCPClient] = None

# simple in-memory session store
sessions: Dict[str, Dict[str, Any]] = {}
configurations: Dict[str, Dict[str, Any]] = {}


def get_or_create_session(session_id: str):
    if session_id not in sessions:
        sessions[session_id] = {"conversation_history": [], "created_at": datetime.now().isoformat(), "last_activity": datetime.now().isoformat()}
    else:
        sessions[session_id]["last_activity"] = datetime.now().isoformat()
    return sessions[session_id]


# Pydantic models
class ChatRequest(BaseModel):
    message: str = Field(..., description="User's message")
    session_id: Optional[str] = Field(None, description="session id")


class ChatResponse(BaseModel):
    response: Any
    session_id: str
    timestamp: str

class AssistantRequest(BaseModel):
    message: str
    session_id: Optional[str] = None
    auto_execute: bool = True
    max_tools: int = 1

class AssistantResponse(BaseModel):
    mode: str = "assistant"
    message: str
    session_id: str
    plan: List[Dict[str, Any]]
    executions: Optional[List[Dict[str, Any]]] = None
    answer: Optional[str] = None
    # For simple UI compatibility (expects `response` like ChatResponse)
    response: Optional[Any] = None


class ConfigurationRequest(BaseModel):
    username: str
    password: str
    base_url: str
    environment: Optional[str] = "DEV"
    session_id: Optional[str] = None

@app.on_event("startup")
async def startup_event():
    global mcp_client
    logger.info("Starting app and creating MCP HTTP client...")
    mcp_client = ChatbotFastMCPClient(server_url="http://localhost:9000/mcp")
    try:
        ok = await mcp_client.health_check()
        if ok:
            logger.info("Connected to MCP server (HTTP).")
        else:
            logger.warning("MCP server not reachable at startup (http://localhost:9000).")
    except Exception as e:
        logger.exception("Startup health check failed: %s", e)


@app.on_event("shutdown")
async def shutdown_event():
    global mcp_client
    if mcp_client:
        await mcp_client.close()
        logger.info("MCP client closed.")
 
 
from typing import List

class ToolSchema(BaseModel):
    name: str
    description: str

@app.get("/tools", response_model=List[ToolSchema])
async def get_tools():
    """
    Returns a flat list of tools/endpoints exposed by the MCP server.
    """
    result = await mcp_client.list_tools()

    if result.get("status") != "success":
        # something went wrong upstream
        detail = result.get("message", "Unknown error fetching tools")
        raise HTTPException(status_code=502, detail=detail)

    # unwrap and return only the list of tools
    return result["tools"]

@app.get("/")
async def root():
    return {"message": "React UI available separately. See frontend/ directory.", "endpoints": ["/configure", "/chat", "/status", "/tools", "/quick_actions", "/run_tool"]}

@app.get("/simple", response_class=HTMLResponse)
async def simple_ui():
        """Return the minimal UI from the external HTML file to avoid inline JS duplication and escaping issues."""
        try:
            html_path = Path(__file__).resolve().parent / "simple_ui.html"
            content = html_path.read_text(encoding="utf-8")
            return HTMLResponse(content=content)
        except Exception as e:
            logger.exception("Failed to read simple_ui.html: %s", e)
            fallback = """
            <!DOCTYPE html>
            <html><head><meta charset='UTF-8'><title>API Assistant (Simple)</title></head>
            <body><p>Failed to load simple_ui.html. Check server logs.</p></body></html>
            """
            return HTMLResponse(content=fallback, status_code=500)
        html = """
        <!DOCTYPE html>
        <html lang='en'>
        <head>
            <meta charset='UTF-8'/>
            <title>API Assistant (Simple)</title>
            <style>
                :root { color-scheme: dark; }
                body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Arial,sans-serif; background:#111; color:#eee; display:flex; flex-direction:column; height:100vh; }
                header { padding:0.75rem 1rem; background:#181818; font-weight:600; letter-spacing:.5px; }
                #log { flex:1; overflow:auto; padding:1rem; line-height:1.4; }
                .msg { margin:0 0 .85rem; }
                .msg.user { color:#9ad6ff; }
                .msg.assistant { color:#c6f6c6; }
                .msg.system { color:#aaa; font-style:italic; }
                .bubble { padding:.6rem .75rem; background:#222; border-radius:8px; display:inline-block; max-width:70ch; white-space:pre-wrap; word-break:break-word; }
                .user .bubble { background:#123d55; }
                .assistant .bubble { background:#1d3d1d; }
                form { display:flex; gap:.5rem; padding:.75rem; background:#181818; }
                input[type=text] { flex:1; padding:.55rem .7rem; border:1px solid #333; border-radius:6px; background:#101010; color:#eee; }
                input[type=text]:focus { outline:2px solid #2c5aa0; }
                button { padding:.55rem 1rem; border:1px solid #2d5fff; background:#2d5fff; color:#fff; border-radius:6px; cursor:pointer; font-weight:600; }
                button:disabled { opacity:.55; cursor:progress; }
                .toolbar { display:flex; gap:1rem; align-items:center; padding:0 .75rem .5rem; font-size:.8rem; flex-wrap:wrap; }
                label { display:inline-flex; align-items:center; gap:.35rem; cursor:pointer; }
                .small { font-size:.7rem; opacity:.65; }
                #status { font-size:.7rem; opacity:.7; margin-left:auto; }
                a { color:#58a6ff; }
            </style>
        </head>
        <body>
            <header>API Assistant (Simple)</header>
            <div class='toolbar'>
                <label><input type='checkbox' id='assistant' checked/> Assistant Auto Tools</label>
                <label>Max Tools <input type='number' id='maxTools' min='1' max='5' value='1' style='width:60px;'/></label>
                <span class='small'>Type a prompt like: <code>pending payments status=pending</code> or <code>cash summary</code></span>
                <span id='status'>Idle</span>
                <button id='cfgBtn' style='margin-left:auto'>Configure</button>
            </div>

            <div id='log'></div>
            <dialog id='cfgDlg'>
                <form method='dialog' id='cfgForm' style='display:flex;flex-direction:column;gap:.5rem;min-width:320px;'>
                    <h3>Configure Credentials</h3>
                    <label>Username <input type='text' id='cfgUser' required></label>
                    <label>Password <input type='password' id='cfgPass' required></label>
                    <label>Base URL <input type='text' id='cfgBase' placeholder='http://127.0.0.1:9001' required></label>
                    <div style='display:flex;gap:.5rem;justify-content:flex-end'>
                        <button value='cancel'>Cancel</button>
                        <button id='cfgSave' value='default'>Save</button>
                    </div>
                    <p class='small'>Tip: DEV/TE1/TE2 can be mapped by Base URL (e.g., http://dev-host:port)</p>
                </form>
            </dialog>
            <form id='chatForm'>
                <input id='input' type='text' autocomplete='off' placeholder='Ask something (e.g., show pending payments status=pending)' />
                <button id='sendBtn' type='submit'>Send</button>

            </form>
            <script>
                const logEl = document.getElementById('log');
                const form = document.getElementById('chatForm');
                const input = document.getElementById('input');
                const assistantToggle = document.getElementById('assistant');
                const maxTools = document.getElementById('maxTools');
                const statusEl = document.getElementById('status');
                const sendBtn = document.getElementById('sendBtn');
                const planBtn = document.getElementById('planBtn');
                const cfgBtn = document.getElementById('cfgBtn');
                const cfgDlg = document.getElementById('cfgDlg');
                const cfgForm = document.getElementById('cfgForm');
                const cfgUser = document.getElementById('cfgUser');
                const cfgPass = document.getElementById('cfgPass');
                const cfgBase = document.getElementById('cfgBase');
                const planContainer = document.getElementById('planContainer');
                const planSummary = document.getElementById('planSummary');
                const executePlanBtn = document.getElementById('executePlanBtn');
                const cancelPlanBtn = document.getElementById('cancelPlanBtn');
                const hidePlanBtn = document.getElementById('hidePlanBtn');
                
                // Surface JS errors in the UI so users see why nothing appears
                function logErrorToUI(text){
                    try{
                        const wrap = document.createElement('div');
                        wrap.className = 'msg system';
                        const bubble = document.createElement('div');
                        bubble.className = 'bubble';
                        bubble.textContent = String(text);
                        wrap.appendChild(bubble);
                        logEl.appendChild(wrap);
                        logEl.scrollTop = logEl.scrollHeight;
                    }catch(_e){ /* ignore */ }
                }
                window.addEventListener('error', (e)=>{
                    const msg = e && (e.message || (e.error && e.error.message)) || 'Unknown script error';
                    logErrorToUI('JS Error: ' + msg);
                });
                window.addEventListener('unhandledrejection', (e)=>{
                    const r = e && e.reason;
                    const msg = typeof r === 'string' ? r : (r && r.message) ? r.message : (r ? JSON.stringify(r) : 'Unknown promise rejection');
                    logErrorToUI('Unhandled rejection: ' + msg);
                });
                
                let currentPlan = null;
                function add(role, content){
                    const wrap = document.createElement('div');
                    wrap.className = 'msg ' + role;
                    const bubble = document.createElement('div');
                    bubble.className = 'bubble';

                    let displayText = content;
                    let plan = null;
                    let executions = null;

                    if(role === 'assistant' && content && typeof content === 'object'){
                        plan = (typeof content.plan !== 'undefined') ? content.plan : null;
                        executions = (typeof content.executions !== 'undefined') ? content.executions : null;
                        if(typeof content.answer === 'string'){
                            displayText = content.answer;
                        } else if(typeof content.response === 'string'){
                            displayText = content.response;
                        } else if(content.response && typeof content.response === 'object'){
                            displayText = JSON.stringify(content.response, null, 2);
                        } else if(content.plan){
                            displayText = 'Plan generated.';
                        } else {
                            displayText = JSON.stringify(content, null, 2);
                        }
                    } else if(typeof displayText === 'object'){
                        displayText = JSON.stringify(displayText, null, 2);
                    }

                    bubble.textContent = displayText;
                    wrap.appendChild(bubble);

                    if(role === 'assistant' && (plan || executions)){
                        const details = document.createElement('details');
                        details.style.marginTop = '0.25rem';
                        const summary = document.createElement('summary');
                        summary.textContent = 'Show reasoning / execution details';
                        details.appendChild(summary);

                        if(plan !== null){
                            const prePlan = document.createElement('pre');
                            prePlan.style.whiteSpace = 'pre-wrap';
                            prePlan.style.margin = '0.5rem 0';
                            prePlan.textContent = 'Plan:\\n' + JSON.stringify(plan, null, 2);
                            details.appendChild(prePlan);
                        }
                        if(executions !== null){
                            const preExec = document.createElement('pre');
                            preExec.style.whiteSpace = 'pre-wrap';
                            preExec.style.margin = '0.5rem 0';
                            preExec.textContent = 'Executions:\\n' + JSON.stringify(executions, null, 2);
                            details.appendChild(preExec);
                        }
                        wrap.appendChild(details);
                    }

                    logEl.appendChild(wrap);
                    logEl.scrollTop = logEl.scrollHeight;
                }

                add('system', 'Assistant ready.');

                cfgBtn.addEventListener('click', ()=> cfgDlg.showModal());
                cfgForm.addEventListener('submit', async (e)=>{
                    e.preventDefault();
                    const body = {
                        username: cfgUser.value.trim(),
                        password: cfgPass.value,
                        base_url: cfgBase.value.trim(),
                        environment: 'DEV'
                    };
                    try{
                        const resp = await fetch('/configure', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
                        if(!resp.ok) throw new Error('HTTP '+resp.status);
                        // optionally, update server spec base URLs so tools hit the same env
                        await fetch('http://127.0.0.1:9000/mcp/spec_base_url', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({base_url: body.base_url})}).catch(()=>{});
                        add('system', 'Configuration saved.');
                        cfgDlg.close();
                    }catch(err){
                        add('assistant', 'Config error: '+err.message);
                    }
                });

                async function callAssistant(message){
                    const body = {
                        message,
                        auto_execute: true,
                        max_tools: parseInt(maxTools.value)||1
                    };
                    const resp = await fetch('/assistant/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
                    if(!resp.ok) throw new Error('HTTP '+resp.status);
                        return resp.json();
                }
                async function callChat(message){
                    const body = {message};
                    const resp = await fetch('/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
                    if(!resp.ok) throw new Error('HTTP '+resp.status);
                    return resp.json();
                }
                


                form.addEventListener('submit', async (e)=>{
                    e.preventDefault();
                    const text = input.value.trim();
                    if(!text) return;
                    input.value='';
                    add('user', text);
                    statusEl.textContent = 'Thinkingâ€¦';
                    sendBtn.disabled = true;
                    planBtn.disabled = true;
                    try {
                        let result;
                        if(assistantToggle.checked){
                            result = await callAssistant(text);
                        } else {
                            result = await callChat(text); // returns ChatResponse shape
                        }
                        add('assistant', result);
                    } catch(err){
                        add('assistant', 'Error: '+ err.message);
                    } finally {
                        sendBtn.disabled = false;
                        planBtn.disabled = false;
                        statusEl.textContent = 'Idle';
                        input.focus();
                    }
                });
            </script>
        </body>
        </html>
        """
        return HTMLResponse(content=html)

@app.get("/quick_actions")
async def quick_actions():
    """Return a curated list of tools to display as quick actions (currently all tools)."""
    result = await get_tools()  # reuse existing logic
    # Could add filtering / sorting later
    return result

@app.get("/tool_meta/{tool_name}")
async def get_tool_meta(tool_name: str):
    """Proxy tool metadata (parameters etc.) from MCP server."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    # Call underlying MCP HTTP server directly via aiohttp session
    try:
        # reuse session
        await mcp_client._ensure_session()  # type: ignore
        async with mcp_client._session.get(f"{mcp_client.server_url}/tool_meta/{tool_name}") as resp:  # type: ignore
            if resp.status == 200:
                return await resp.json()
            detail = await resp.text()
            raise HTTPException(status_code=resp.status, detail=detail)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/run_tool")
async def run_tool(payload: Dict[str, Any]):
    """Directly execute a tool (wrapper around MCP client)."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    tool_name = payload.get("tool_name")
    arguments = payload.get("arguments") or {}
    if not tool_name:
        raise HTTPException(status_code=400, detail="tool_name required")
    try:
        result = await mcp_client.call_tool(tool_name, **arguments)
        logger.info("/run_tool %s -> status=%s code=%s", tool_name, result.get('status'), result.get('status_code'))
        return {"status": "success", "tool": tool_name, "result": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/configure")
async def configure_credentials(req: ConfigurationRequest):
    global mcp_client, configurations
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    session_id = req.session_id or "default"
    configurations[session_id] = {
        "username": req.username,
        "password": req.password,
        "base_url": req.base_url,
        "environment": req.environment,
        "configured_at": datetime.now().isoformat()
    }
    # apply to global client (for simplicity)
    mcp_client.username = req.username
    mcp_client.password = req.password
    mcp_client.base_url = req.base_url
    mcp_client.environment = req.environment
    # mark unauthenticated so next ask_question triggers login attempt
    mcp_client.authenticated = False
    return {"status": "success", "message": "configuration stored"}


@app.get("/configuration/{session_id}")
async def get_configuration(session_id: str):
    cfg = configurations.get(session_id)
    if not cfg:
        return JSONResponse(status_code=404, content={"status": "not_configured", "message": "No configuration for this session."})
    return {"status": "configured", "username": cfg["username"], "base_url": cfg["base_url"], "environment": cfg["environment"], "configured_at": cfg["configured_at"]}


@app.post("/chat", response_model=ChatResponse)
async def chat_endpoint(req: ChatRequest):
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")

    session_id = req.session_id or "default"
    session = get_or_create_session(session_id)
    session["conversation_history"].append({"role": "user", "content": req.message, "timestamp": datetime.now().isoformat()})

    cfg = configurations.get(session_id)
    if not cfg:
        # Allow discovery questions pre-configuration
        lowered = req.message.lower().strip()
        # Broad heuristic: question contains 'api' or 'endpoint' and a query word
        query_words = ["what", "which", "list", "show", "available"]
        if ("api" in lowered or "endpoint" in lowered) and any(q in lowered for q in query_words):
            specs_result = await mcp_client.call_tool("list_loaded_specs")
            endpoints_result = await mcp_client.call_tool("list_api_endpoints")
            specs = specs_result.get("specs", []) if isinstance(specs_result, dict) else []
            grouped = endpoints_result.get("grouped", {}) if isinstance(endpoints_result, dict) else {}
            endpoint_count = endpoints_result.get("count", sum(len(v) for v in grouped.values())) if isinstance(endpoints_result, dict) else 0
            human_list = ", ".join([s.get("name", "?") for s in specs]) or "(none loaded)"
            summary = {
                "status": "success",
                "message": f"Loaded API specs: {human_list} ({endpoint_count} endpoints). Use /configure or the UI configuration to add credentials.",
                "specs": specs,
                "endpoint_count": endpoint_count,
                "grouped": grouped
            }
            return ChatResponse(response=summary, session_id=session_id, timestamp=datetime.now().isoformat())
        return ChatResponse(response={"status": "configuration_required", "message": "Please configure your credentials."}, session_id=session_id, timestamp=datetime.now().isoformat())

    # apply config to client for this request
    mcp_client.username = cfg["username"]
    mcp_client.password = cfg["password"]
    mcp_client.base_url = cfg["base_url"]
    mcp_client.environment = cfg.get("environment", "DEV")

    # ensure login once before delegating to assistant
    if not mcp_client.authenticated:
        login_result = await mcp_client.login()
        if login_result.get("status") == "error":
            return ChatResponse(response={"status": "error", "message": f"Login failed: {login_result.get('message')}"} , session_id=session_id, timestamp=datetime.now().isoformat())
        mcp_client.authenticated = True

    # Delegate to assistant mode for planning/execution; reuse internal function
    assistant_req = AssistantRequest(message=req.message, session_id=session_id, auto_execute=True, max_tools=3)
    assistant_resp = await assistant_chat(assistant_req)  # type: ignore
    # Record assistant answer to session
    answer_payload = assistant_resp.response if hasattr(assistant_resp, 'response') else getattr(assistant_resp, 'answer', None)
    session["conversation_history"].append({"role": "assistant", "content": answer_payload, "timestamp": datetime.now().isoformat()})
    return ChatResponse(response=answer_payload, session_id=session_id, timestamp=datetime.now().isoformat())




@app.post('/assistant/chat', response_model=AssistantResponse)
async def assistant_chat(req: AssistantRequest):
    """Single-agent flow: delegate planning+execution to the LLM agent and return its answer."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail='MCP client not initialized')

    session_id = req.session_id or 'default'
    session = get_or_create_session(session_id)
    session['conversation_history'].append({'role': 'user', 'content': req.message, 'timestamp': datetime.now().isoformat()})

    try:
        # Call the MCP server's agent endpoint
        agent_response = await mcp_client.call_llm_agent(req.message)
        
        if agent_response.get('status') == 'error':
            raise HTTPException(status_code=500, detail=agent_response.get('message', 'Agent execution failed'))
        
        # Record assistant answer to session
        answer = agent_response.get('answer', 'No answer provided.')
        session['conversation_history'].append({'role': 'assistant', 'content': answer, 'timestamp': datetime.now().isoformat()})
        
        return AssistantResponse(
            mode="assistant",
            message=req.message,
            session_id=session_id,
            plan=agent_response.get('plan', {}),
            executions=agent_response.get('executions', []),
            answer=answer,
            response=agent_response
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Assistant chat error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/test_endpoint")
async def test_endpoint(data: dict):
    return {"received": data, "status": "ok"}

@app.get("/status")
async def get_status():
    global mcp_client
    if not mcp_client:
        return {"mcp_server_connected": False, "available_tools": 0, "error": "Client not initialized"}
    try:
        connected = await mcp_client.health_check()
        tools_count = 0
        if connected:
            # use list_tools helper
            tools = await mcp_client.list_tools()
            if isinstance(tools, dict) and tools.get("status") == "success":
                tools_count = len(tools.get("tools", []))
            elif isinstance(tools, dict) and "tools" in tools:
                tools_count = len(tools["tools"])
        return {"mcp_server_connected": connected, "available_tools": tools_count, "server_timestamp": datetime.now().isoformat()}
    except Exception as e:
        logger.exception("status check failed")
        return {"mcp_server_connected": False, "available_tools": 0, "error": str(e)}

@app.get("/apis")
async def list_apis():
    """Return loaded spec names and number of tools each (no auth required)."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    specs = await mcp_client.get_tool_meta("list_loaded_specs") if hasattr(mcp_client, 'get_tool_meta') else None  # placeholder
    # Fallback: we can't call list directly via tool_meta; use chat CALL_TOOL fallback
    result = await mcp_client.call_tool("list_loaded_specs")
    if result.get("status") == "success" and "specs" in result:
        return result
    return {"status": "error", "message": "Could not retrieve specs", "raw": result}


@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    await websocket.accept()
    global mcp_client
    if not mcp_client:
        await websocket.close(code=1011, reason="Server not initialized")
        return
    try:
        while True:
            data = await websocket.receive_text()
            try:
                payload = json.loads(data)
                message = payload.get("message")
            except Exception:
                message = data
            # forward to backend
            result = await mcp_client.ask_question(message)
            await websocket.send_json({"response": result, "timestamp": datetime.now().isoformat()})
    except WebSocketDisconnect:
        logger.info("WebSocket disconnected for session %s", session_id)
    except Exception as e:
        logger.exception("ws error")
        try:
            await websocket.close(code=1011, reason=str(e))
        except Exception:
            pass


if __name__ == "__main__":
    logger.info("Starting uvicorn for chatbot_app on 0.0.0.0:9080")
    uvicorn.run("chatbot_app:app", host="0.0.0.0", port=9080, reload=True, log_level="info")
