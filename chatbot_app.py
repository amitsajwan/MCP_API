#!/usr/bin/env python3
"""
FastAPI-based Chatbot Application (frontend)
- Serves a simple HTML chat UI at /
- Uses ChatbotFastMCPClient (HTTP client) to communicate with the OpenAPI MCP Server
"""

import json
import logging
import os
from datetime import datetime
from typing import Dict, Any, Optional
from fastapi import FastAPI, Request, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse
from pydantic import BaseModel, Field
import uvicorn
import asyncio

from fastmcp_client import ChatbotFastMCPClient

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("chatbot_app")

app = FastAPI(title="Financial API Chatbot", version="1.0")

# Serve production frontend build if available (generated by `npm run build` in frontend/)
if os.path.isdir("frontend/dist"):
    app.mount("/app", StaticFiles(directory="frontend/dist", html=True), name="frontend")

# CORS for React dev server (default Vite 5173 / CRA 3000)
app.add_middleware(
    CORSMiddleware,
    allow_origins=[],  # use regex instead for all localhost ports
    allow_origin_regex=r"http://(localhost|127\.0\.0\.1):\d+",
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# global client
mcp_client: Optional[ChatbotFastMCPClient] = None

# simple in-memory session store
sessions: Dict[str, Dict[str, Any]] = {}
configurations: Dict[str, Dict[str, Any]] = {}


def get_or_create_session(session_id: str):
    if session_id not in sessions:
        sessions[session_id] = {"conversation_history": [], "created_at": datetime.now().isoformat(), "last_activity": datetime.now().isoformat()}
    else:
        sessions[session_id]["last_activity"] = datetime.now().isoformat()
    return sessions[session_id]


# Pydantic models
class ChatRequest(BaseModel):
    message: str = Field(..., description="User's message")
    session_id: Optional[str] = Field(None, description="session id")


class ChatResponse(BaseModel):
    response: Any
    session_id: str
    timestamp: str

class AssistantRequest(BaseModel):
    message: str
    session_id: Optional[str] = None
    auto_execute: bool = True
    max_tools: int = 1

class AssistantResponse(BaseModel):
    mode: str = "assistant"
    message: str
    session_id: str
    plan: Dict[str, Any]
    executions: Optional[Any] = None
    answer: Optional[str] = None


class ConfigurationRequest(BaseModel):
    username: str
    password: str
    base_url: str
    environment: Optional[str] = "DEV"
    session_id: Optional[str] = None

@app.on_event("startup")
async def startup_event():
    global mcp_client
    logger.info("Starting app and creating MCP HTTP client...")
    mcp_client = ChatbotFastMCPClient(server_url="http://localhost:8000/mcp")
    try:
        ok = await mcp_client.health_check()
        if ok:
            logger.info("Connected to MCP server (HTTP).")
        else:
            logger.warning("MCP server not reachable at startup (http://localhost:8000).")
    except Exception as e:
        logger.exception("Startup health check failed: %s", e)


@app.on_event("shutdown")
async def shutdown_event():
    global mcp_client
    if mcp_client:
        await mcp_client.close()
        logger.info("MCP client closed.")
 
 
from pydantic import BaseModel
from typing import List

class ToolSchema(BaseModel):
    name: str
    description: str

@app.get("/tools", response_model=List[ToolSchema])
async def get_tools():
    """
    Returns a flat list of tools/endpoints exposed by the MCP server.
    """
    result = await mcp_client.list_tools()

    if result.get("status") != "success":
        # something went wrong upstream
        detail = result.get("message", "Unknown error fetching tools")
        raise HTTPException(status_code=502, detail=detail)

    # unwrap and return only the list of tools
    return result["tools"]

@app.get("/")
async def root():
    return {"message": "React UI available separately. See frontend/ directory.", "endpoints": ["/configure", "/chat", "/status", "/tools", "/quick_actions", "/run_tool"]}

@app.get("/simple", response_class=HTMLResponse)
async def simple_ui():
        """Return a minimal, dependency-free conversational UI (assistant-aware)."""
        html = """
        <!DOCTYPE html>
        <html lang='en'>
        <head>
            <meta charset='UTF-8'/>
            <title>API Assistant (Simple)</title>
            <style>
                :root { color-scheme: dark; }
                body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Arial,sans-serif; background:#111; color:#eee; display:flex; flex-direction:column; height:100vh; }
                header { padding:0.75rem 1rem; background:#181818; font-weight:600; letter-spacing:.5px; }
                #log { flex:1; overflow:auto; padding:1rem; line-height:1.4; }
                .msg { margin:0 0 .85rem; }
                .msg.user { color:#9ad6ff; }
                .msg.assistant { color:#c6f6c6; }
                .msg.system { color:#aaa; font-style:italic; }
                .bubble { padding:.6rem .75rem; background:#222; border-radius:8px; display:inline-block; max-width:70ch; white-space:pre-wrap; word-break:break-word; }
                .user .bubble { background:#123d55; }
                .assistant .bubble { background:#1d3d1d; }
                form { display:flex; gap:.5rem; padding:.75rem; background:#181818; }
                input[type=text] { flex:1; padding:.55rem .7rem; border:1px solid #333; border-radius:6px; background:#101010; color:#eee; }
                input[type=text]:focus { outline:2px solid #2c5aa0; }
                button { padding:.55rem 1rem; border:1px solid #2d5fff; background:#2d5fff; color:#fff; border-radius:6px; cursor:pointer; font-weight:600; }
                button:disabled { opacity:.55; cursor:progress; }
                .toolbar { display:flex; gap:1rem; align-items:center; padding:0 .75rem .5rem; font-size:.8rem; flex-wrap:wrap; }
                label { display:inline-flex; align-items:center; gap:.35rem; cursor:pointer; }
                .small { font-size:.7rem; opacity:.65; }
                #status { font-size:.7rem; opacity:.7; margin-left:auto; }
                a { color:#58a6ff; }
            </style>
        </head>
        <body>
            <header>API Assistant (Simple)</header>
            <div class='toolbar'>
                <label><input type='checkbox' id='assistant' checked/> Assistant Auto Tools</label>
                <label>Max Tools <input type='number' id='maxTools' min='1' max='5' value='1' style='width:60px;'/></label>
                <span class='small'>Type a prompt like: <code>pending payments status=pending</code> or <code>cash summary</code></span>
                <span id='status'>Idle</span>
            </div>
            <div id='log'></div>
            <form id='chatForm'>
                <input id='input' type='text' autocomplete='off' placeholder='Ask something (e.g., show pending payments status=pending)' />
                <button id='sendBtn' type='submit'>Send</button>
            </form>
            <script>
                const logEl = document.getElementById('log');
                const form = document.getElementById('chatForm');
                const input = document.getElementById('input');
                const assistantToggle = document.getElementById('assistant');
                const maxTools = document.getElementById('maxTools');
                const statusEl = document.getElementById('status');
                const sendBtn = document.getElementById('sendBtn');

                function add(role, content){
                    const wrap = document.createElement('div');
                    wrap.className = 'msg ' + role;
                    const bubble = document.createElement('div');
                    bubble.className = 'bubble';
                    if(typeof content === 'object') content = JSON.stringify(content, null, 2);
                    bubble.textContent = content;
                    wrap.appendChild(bubble);
                    logEl.appendChild(wrap);
                    logEl.scrollTop = logEl.scrollHeight;
                }

                add('system', 'Assistant ready.');

                async function callAssistant(message){
                    const body = {
                        message,
                        auto_execute: true,
                        max_tools: parseInt(maxTools.value)||1
                    };
                    const resp = await fetch('/assistant/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
                    if(!resp.ok) throw new Error('HTTP '+resp.status);
                        return resp.json();
                }
                async function callChat(message){
                    const body = {message};
                    const resp = await fetch('/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
                    if(!resp.ok) throw new Error('HTTP '+resp.status);
                    return resp.json();
                }

                form.addEventListener('submit', async (e)=>{
                    e.preventDefault();
                    const text = input.value.trim();
                    if(!text) return;
                    input.value='';
                    add('user', text);
                    statusEl.textContent = 'Thinkingâ€¦';
                    sendBtn.disabled = true;
                    try {
                        let result;
                        if(assistantToggle.checked){
                            result = await callAssistant(text);
                        } else {
                            result = await callChat(text); // returns ChatResponse shape
                        }
                        add('assistant', result.response || result.plan || result);
                    } catch(err){
                        add('assistant', 'Error: '+ err.message);
                    } finally {
                        sendBtn.disabled = false;
                        statusEl.textContent = 'Idle';
                        input.focus();
                    }
                });
            </script>
        </body>
        </html>
        """
        return HTMLResponse(content=html)

@app.get("/quick_actions")
async def quick_actions():
    """Return a curated list of tools to display as quick actions (currently all tools)."""
    result = await get_tools()  # reuse existing logic
    # Could add filtering / sorting later
    return result

@app.get("/tool_meta/{tool_name}")
async def get_tool_meta(tool_name: str):
    """Proxy tool metadata (parameters etc.) from MCP server."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    # Call underlying MCP HTTP server directly via aiohttp session
    try:
        # reuse session
        await mcp_client._ensure_session()  # type: ignore
        async with mcp_client._session.get(f"{mcp_client.server_url}/tool_meta/{tool_name}") as resp:  # type: ignore
            if resp.status == 200:
                return await resp.json()
            detail = await resp.text()
            raise HTTPException(status_code=resp.status, detail=detail)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/run_tool")
async def run_tool(payload: Dict[str, Any]):
    """Directly execute a tool (wrapper around MCP client)."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    tool_name = payload.get("tool_name")
    arguments = payload.get("arguments") or {}
    if not tool_name:
        raise HTTPException(status_code=400, detail="tool_name required")
    try:
        result = await mcp_client.call_tool(tool_name, **arguments)
        return {"status": "success", "tool": tool_name, "result": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/configure")
async def configure_credentials(req: ConfigurationRequest):
    global mcp_client, configurations
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    session_id = req.session_id or "default"
    configurations[session_id] = {
        "username": req.username,
        "password": req.password,
        "base_url": req.base_url,
        "environment": req.environment,
        "configured_at": datetime.now().isoformat()
    }
    # apply to global client (for simplicity)
    mcp_client.username = req.username
    mcp_client.password = req.password
    mcp_client.base_url = req.base_url
    mcp_client.environment = req.environment
    # mark unauthenticated so next ask_question triggers login attempt
    mcp_client.authenticated = False
    return {"status": "success", "message": "configuration stored"}


@app.get("/configuration/{session_id}")
async def get_configuration(session_id: str):
    cfg = configurations.get(session_id)
    if not cfg:
        return JSONResponse(status_code=404, content={"status": "not_configured", "message": "No configuration for this session."})
    return {"status": "configured", "username": cfg["username"], "base_url": cfg["base_url"], "environment": cfg["environment"], "configured_at": cfg["configured_at"]}


@app.post("/chat", response_model=ChatResponse)
async def chat_endpoint(req: ChatRequest):
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")

    session_id = req.session_id or "default"
    session = get_or_create_session(session_id)
    session["conversation_history"].append({"role": "user", "content": req.message, "timestamp": datetime.now().isoformat()})

    cfg = configurations.get(session_id)
    if not cfg:
        # Allow discovery questions pre-configuration
        lowered = req.message.lower().strip()
        # Broad heuristic: question contains 'api' or 'endpoint' and a query word
        query_words = ["what", "which", "list", "show", "available"]
        if ("api" in lowered or "endpoint" in lowered) and any(q in lowered for q in query_words):
            specs_result = await mcp_client.call_tool("list_loaded_specs")
            endpoints_result = await mcp_client.call_tool("list_api_endpoints")
            specs = specs_result.get("specs", []) if isinstance(specs_result, dict) else []
            grouped = endpoints_result.get("grouped", {}) if isinstance(endpoints_result, dict) else {}
            endpoint_count = endpoints_result.get("count", sum(len(v) for v in grouped.values())) if isinstance(endpoints_result, dict) else 0
            human_list = ", ".join([s.get("name", "?") for s in specs]) or "(none loaded)"
            summary = {
                "status": "success",
                "message": f"Loaded API specs: {human_list} ({endpoint_count} endpoints). Use /configure or the UI configuration to add credentials.",
                "specs": specs,
                "endpoint_count": endpoint_count,
                "grouped": grouped
            }
            return ChatResponse(response=summary, session_id=session_id, timestamp=datetime.now().isoformat())
        return ChatResponse(response={"status": "configuration_required", "message": "Please configure your credentials."}, session_id=session_id, timestamp=datetime.now().isoformat())

    # apply config to client for this request
    mcp_client.username = cfg["username"]
    mcp_client.password = cfg["password"]
    mcp_client.base_url = cfg["base_url"]
    mcp_client.environment = cfg.get("environment", "DEV")

    # ensure login
    if not mcp_client.authenticated:
        login_result = await mcp_client.login()
        if login_result.get("status") == "error":
            return ChatResponse(response={"status": "error", "message": f"Login failed: {login_result.get('message')}"} , session_id=session_id, timestamp=datetime.now().isoformat())
        mcp_client.authenticated = True

    # ask question
    answer = await mcp_client.ask_question(req.message)
    # store assistant reply to session history (best-effort)
    session["conversation_history"].append({"role": "assistant", "content": answer, "timestamp": datetime.now().isoformat()})

    return ChatResponse(response=answer, session_id=session_id, timestamp=datetime.now().isoformat())


def _score_tool(message_tokens: set, tool_name: str, description: str) -> tuple[float, set]:
    """Very lightweight relevance score: token overlap across name/description."""
    name_tokens = {t.lower() for t in tool_name.replace('_', ' ').split()}
    desc_tokens = {t.lower() for t in (description or '').replace('_', ' ').split()}
    all_tokens = name_tokens | desc_tokens
    overlap = message_tokens & all_tokens
    # heuristic: weight name matches slightly higher
    score = 0.0
    for tok in overlap:
        score += (1.5 if tok in name_tokens else 1.0)
    # normalize by log size to avoid bias toward long names
    if all_tokens:
        score = score / (len(all_tokens) ** 0.5)
    return score, overlap

def _parse_inline_args(message: str) -> Dict[str, Any]:
    """Parse simple key=value pairs in the message (e.g., status=pending limit=5)."""
    args: Dict[str, Any] = {}
    for part in message.split():
        if '=' in part:
            k, v = part.split('=', 1)
            k = k.strip().lower()
            v = v.strip().strip(',')
            # naive casting
            if v.isdigit():
                args[k] = int(v)
            else:
                try:
                    args[k] = float(v)
                except ValueError:
                    args[k] = v
    return args

def _synthesize_answer(executions: list) -> str:
    if not executions:
        return "No tool executions were performed."
    lines = []
    aggregate_counts = []
    for ex in executions:
        if ex.get('status') != 'success':
            lines.append(f"{ex.get('tool')}: error {ex.get('error')}")
            continue
        res = ex.get('result')
        # Standard FastAPI endpoint wrapper shape {status, url, status_code, response}
        payload = res.get('response') if isinstance(res, dict) else res
        count_info = None
        # Try to locate primary list
        if isinstance(payload, list):
            count_info = (len(payload), 'items')
        elif isinstance(payload, dict):
            # pick the largest list value
            best_key = None; best_len = -1
            for k,v in payload.items():
                if isinstance(v, list):
                    l = len(v)
                    if l > best_len:
                        best_len = l; best_key = k
            if best_key is not None:
                count_info = (best_len, best_key)
        if count_info:
            n, label = count_info
            aggregate_counts.append((ex.get('tool'), n, label))
            lines.append(f"{ex.get('tool')}: {n} {label}")
        else:
            lines.append(f"{ex.get('tool')}: succeeded")
    if not aggregate_counts:
        return "; ".join(lines)
    summary_parts = [f"{n} from {tool}" for tool, n, _ in aggregate_counts]
    total = sum(n for _, n, _ in aggregate_counts)
    return "; ".join(lines) + f". Total items across tools: {total} (" + ", ".join(summary_parts) + ")"

@app.post('/assistant/chat', response_model=AssistantResponse)
async def assistant_chat(req: AssistantRequest):
    """Assistant mode: attempt to map natural language to one or more tools and execute them.
    Returns a plan (candidate tools with scores + chosen selection) and optional execution results.
    """
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail='MCP client not initialized')

    session_id = req.session_id or 'default'
    session = get_or_create_session(session_id)
    session['conversation_history'].append({'role': 'user', 'content': req.message, 'timestamp': datetime.now().isoformat()})

    # Ensure specs known (list tools)
    tools_list = await mcp_client.list_tools()
    if tools_list.get('status') != 'success':
        raise HTTPException(status_code=502, detail='Could not list tools')
    tool_objs = tools_list.get('tools', [])

    # Tokenize message + simple inference (pending -> status=pending if not already provided)
    raw_tokens = [t.lower().strip(',.!?') for t in req.message.split() if t]
    inline_args = _parse_inline_args(req.message)
    if 'pending' in raw_tokens and 'status' not in inline_args:
        inline_args['status'] = 'pending'
    message_tokens = set(raw_tokens)

    scored = []
    for t in tool_objs:
        name = t.get('name') if isinstance(t, dict) else str(t)
        desc = t.get('description', '') if isinstance(t, dict) else ''
        score, overlap = _score_tool(message_tokens, name, desc)
        if score > 0:
            scored.append({'tool': name, 'score': round(score, 4), 'overlap': sorted(list(overlap))})

    # Fallback: if nothing matched, provide suggestions listing tools
    if not scored:
        plan = {
            'candidates': [],
            'selected': [],
            'note': 'No obvious tool match; try mentioning a resource like payments, transactions, summary.'
        }
        return AssistantResponse(message=req.message, session_id=session_id, plan=plan, executions=None)

    scored.sort(key=lambda x: x['score'], reverse=True)
    # Multi-tool heuristic: if user mentions 'all', 'both', 'summary' choose up to req.max_tools (default 1)
    want_multi = any(t in message_tokens for t in {'all','both','summary'}) or req.max_tools > 1
    limit = req.max_tools if want_multi else 1
    selected = [c['tool'] for c in scored[: max(1, limit)]]

    # inline_args already parsed / augmented above

    executions = []
    if req.auto_execute:
        for tool_name in selected:
            try:
                result = await mcp_client.call_tool(tool_name, **inline_args)
                executions.append({'tool': tool_name, 'status': 'success', 'result': result})
            except Exception as e:
                executions.append({'tool': tool_name, 'status': 'error', 'error': str(e)})

    plan = {
        'candidates': scored,
        'selected': selected,
        'arguments': inline_args,
        'executed': bool(executions)
    }
    # Append assistant reply summary to history
    session['conversation_history'].append({'role': 'assistant', 'content': plan, 'timestamp': datetime.now().isoformat()})
    answer = _synthesize_answer(executions) if executions else None
    return AssistantResponse(message=req.message, session_id=session_id, plan=plan, executions=executions, answer=answer)


@app.get("/status")
async def get_status():
    global mcp_client
    if not mcp_client:
        return {"mcp_server_connected": False, "available_tools": 0, "error": "Client not initialized"}
    try:
        connected = await mcp_client.health_check()
        tools_count = 0
        if connected:
            # use list_tools helper
            tools = await mcp_client.list_tools()
            if isinstance(tools, dict) and tools.get("status") == "success":
                tools_count = len(tools.get("tools", []))
            elif isinstance(tools, dict) and "tools" in tools:
                tools_count = len(tools["tools"])
        return {"mcp_server_connected": connected, "available_tools": tools_count, "server_timestamp": datetime.now().isoformat()}
    except Exception as e:
        logger.exception("status check failed")
        return {"mcp_server_connected": False, "available_tools": 0, "error": str(e)}

@app.get("/apis")
async def list_apis():
    """Return loaded spec names and number of tools each (no auth required)."""
    global mcp_client
    if not mcp_client:
        raise HTTPException(status_code=503, detail="MCP client not initialized")
    specs = await mcp_client.get_tool_meta("list_loaded_specs") if hasattr(mcp_client, 'get_tool_meta') else None  # placeholder
    # Fallback: we can't call list directly via tool_meta; use chat CALL_TOOL fallback
    result = await mcp_client.call_tool("list_loaded_specs")
    if result.get("status") == "success" and "specs" in result:
        return result
    return {"status": "error", "message": "Could not retrieve specs", "raw": result}


@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    await websocket.accept()
    global mcp_client
    if not mcp_client:
        await websocket.close(code=1011, reason="Server not initialized")
        return
    try:
        while True:
            data = await websocket.receive_text()
            try:
                payload = json.loads(data)
                message = payload.get("message")
            except Exception:
                message = data
            # forward to backend
            result = await mcp_client.ask_question(message)
            await websocket.send_json({"response": result, "timestamp": datetime.now().isoformat()})
    except WebSocketDisconnect:
        logger.info("WebSocket disconnected for session %s", session_id)
    except Exception as e:
        logger.exception("ws error")
        try:
            await websocket.close(code=1011, reason=str(e))
        except Exception:
            pass


if __name__ == "__main__":
    logger.info("Starting uvicorn for chatbot_app on 0.0.0.0:8080")
    uvicorn.run("chatbot_app:app", host="0.0.0.0", port=8080, reload=True, log_level="info")
